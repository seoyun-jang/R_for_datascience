---
title: "3.2 Filter rows with fliter()"
author: "seo yun Jang"
date: '2022 2 7 '
output: html_document
---
```{r, warning=FALSE}
library(tidyr)
library(tidyverse)
library(dplyr)
library(ggplot2)

flights <- nycflights13::flights
```

## 3.2 filter()로 행 필터링하기

filter()를 이용하면 값을 기준으로 데이터를 서브셋 할 수 있다.  
첫 번째 인수는 데이터프레임 이름을, 두 번째 이후의 인수들은 데이터프레임을 필터링하는 표현식들이다.
```{r}
# example : 1월 1일 항공편 모두를 선택
filter(flights, month == 1, day == 1)
(jan1 <- filter(flights, month ==1, day ==1))

```
dplyr 함수들은 입력을 절대 수정하지 않기 때문에, 결과를 저장하려면 할당 연산자 <- 를 사용해야한다.  
결과를 출력하면서 변수에 저장하기 위해서는 할당문을 괄호로 묶는다.
```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

### 3.2.1 비교 연산
```
# example
filter(flights, month=1)

```
위와 같이 실행했을 때 Did you mean `month == 1`? 라는 에러 메세지를 통해 할 수 있듯이 = 대신 ==를 사용하며, 같지 않은 경우 ==!를 사용한다
```{r}
# example
filter(flights, day ==! 3)
```

=를 사용할 때 자주 발생하는 다른 문제는 부동소수점 숫자이다.
```{r}
# example
sqrt(2) ^ 2 == 2
1/49 * 49 == 1
```
컴퓨터는 유한 정밀도 산술을 사용하므로 위와 같은 상황의 결과값은 근사값이다.
```{r}
near(sqrt(2) ^ 2, 2)
near(1 / 49 * 49, 1)
```

### 3.2.2 논리 연산자
filter의 인수들은 'and'로 결합된다. 즉, 모든 표현식이 참이어야 행이 출력에 포함된다. 다른 유형의 조합을 만들려면 직접 불(Boolean) 연산자를 사용해야한다.
`&`는 and, `|`는 or, `!`는 not을 의미한다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdINQKr%2Fbtq64wT3AgH%2FLqgoZaOxvowfPPwyxShY2K%2Fimg.png)

```{r}
# example : 11월이나 12월에 출발한 항공편 모두 찾기
(filter(flights, month == 11 | month == 12))
```
연산순서는 영어에서의 순서와 다르다. `filter(flights, month == 11 | 12)`로 쓰면 직역으로 'finds all flights that departed in November or December'로 번역할 수 있지만 이렇게 쓰게 될 경우 R은 11우러이나 12월에 출발한 항공편 대신 11 | 12(이 표현식은 TRUE가 된다)와 같은 달을 모두 찾는다. 따라서 수치형 문맥에서 TRUE는 1이므로 1월의 모든 항공편을 찾게 된다.  
이 문제에 유용한 팁은 `x %in% y`이다. 이는 x가 y에 있는 값 중 하나인 행을 모두 선택한다.

```{r}
(filter(flights, month %in% c(11, 12)))
```

드모르간법칙을 이용하여 복잡한 서브셋 동작을 단순화 할 수도 있다.  
```{}
!(x & y) == !x | !y
!(x | y) == !x & !y
```

```{r}
# example: 출발 혹은 도착에서 두 시간 이상 지연되지 않은 항공편을 모두 찾는 경우
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

### 3.2.3 결측값
R에서 비교를 까다롭게 만드는 중요한 특징은 결측값, 즉 NA(Not Available)이다. NA는 모르는 값을 나타내므로 결측값은 '파급된다'. 즉 모르는 값이 연관된 연산의 결과도 대부분 모르는 값이 된다.
```{r}
NA > 5
10 == NA
NA + 10
NA / 2
```
```{r}
NA == NA

# 위의 논리는 문맥이 더 있으면 왜 이것이 사실인지 이해하기 쉽다

#x = 메리의 나이이다. 우리는 그녀가 몇 살인지 모른다.
x <- NA

# y = 존의 나이이다. 우리는 그가 몇 살인지 모른다.
y <- NA

# 존과 메리의 나이는 같은가? > 알 수 없다
x == y
```

값이 결측인지를 확인하고 싶으면 `is.na()`를 사용한다.
```{r}
is.na(x)
```

filter()는 조건이 TRUE인 열만 포함한다. FALSE와 NA값들은 제외한다. 결측값들을 남기려면 명시적으로 요청해야한다.
```{r}
#example
df <- tibble(x = c(1,NA,3))

(filter(df, x > 1))
(filter(df, is.na(x) | x > 1))
```

### 3.2.4 연습문제
1. 다음 조건을 만족하는 항공편을 모두 찾아라
  
```{r}
# a. 2시간 이상 도착 지연
filter(flights, dep_delay >= 120)

# b. 휴스턴(IAH 혹은 HOU)으로 운항
filter(flights, dest %in% c("IAH", "HOU"))

# c. 유나이티드항공(United), 아메리칸항공(American), 델타항공(Delta)이 운항
# UA, AA, DL
filter(flights, carrier %in% c("UA", "AA", "DL"))

# d. 여름(7, 8, 9)에 출발
filter(flights, month %in% c(7,8,9))

# e. 2시간 이상 지연 도착했지만, 지연출발하지는 않음
filter(flights, arr_delay >= 120 & dep_delay <= 0)


# f. 최소 한시간 이상 지연출발했지만 운항 중 30분 이상 단축
filter(flights, dep_delay >= 60 & arr_delay <= -30)

# g. 자정과 6am(포함) 사이에 출발
filter(flights, dep_time ==2400 | dep_time >= 1 & dep_time <= 559 )

```

2. 다른 유용한 dplyr 필터링 도우미로 `between()`이 있다. 어떤일을 하는가? 이 도우미로 이전 문제들을 해결한느 데 사용한 코드들을 단순하게 할 수 있는가?
- `btween()`은 

3. `dep_time`이 결측인 항공편은 몇 편인가? 어떤 다른 변수들이 결측인가? 이 열들이 나타내는 것은 무엇이겠는가?
```{r}
dim(filter(flights, is.na(dep_time)))
```
- dep_time이 결측인 항공편은 8255편이다.  
- 이 외에도 실제 도착시간, 실제 출발시간, 출발 지연시간, 도착 지연시간 값에 결측이 있다.  

4. `NA^ 0`은 왜 결측이 아닌가? `NA | TRUE`는 왜 결측이 아닌가? `FALSE & NA`는 왜 결측이 아닌가? 일반 규칙을 발견할 수 있는가?  
- 모든 숫자에 0제곱은 1로 동일하기 때문이다.
- FALSE | TRUE 결과도 TRUE임을 통해 알 수 없는 값, 즉 NA | TRUE의 결과도 TRUE임을 알 수 있다.
- TRUE & FALSE의 결과도 FALSE임을 통해 알 수 없는 값, 즉 NA & FALSE의 결과도 FALSE임을 알 수 있다.
